% Specification of the STOKR Smart Contracts
% SICOS
% Nov 2018


Abstract
========

*STOKR* is as crowd-investing platform based on smart contracts on the
[Ethereum] blockchain.
On *STOKR* many projects will be deployed with the same smart contract
structure (see [project manager](#manager)).
There will be a shared [whitelist](#whitelist) for all projects on *STOKR*.
Each project has its own [ERC20] [Token](#token) and its
[crowdsale](#crowdsale) contract instance.
The token contract is able to distribute profits generated by the projects
to the token holders.

[Ethereum]: https://www.ethereum.org



Ownable Contracts  {#ownable}
=================

Purpose
-------

All of the following contracts are ownable, that is they have an *owner*
address---either another contract instance or an externally owned
account---assigned which has special permissions on the contract.
An owner is initially (i.e. upon deployment) the contract deployer, but
may [transfer the ownership](#ownable-func-transfer) to another address.


Functionality
-------------

This functionality is shared by all following contracts.

### Ownership Transfer  {#ownable-func-transfer}

Transfer the contract instance's ownership to a new address.

**Note:**
The actual ownership transfer doesn't happen immediately.
The designated new owner has to [claim](#ownable-func-transfer) first,
to become the effective new owner.
Thus, transferring the ownership to an invalid address is avoided.

Function
~ `transferOwnerShip(address)`

Restrictions
~ only by current owner

Emitted events
~ `OwnershipTransferred(address, address)`


### Ownership Claiming {#ownable-func-claim}

Claiming the ownership.

Function
~ `claimOwnership()`

Restrictions
~ only by the designated `newOwner`



Whitelist Contract  {#whitelist}
==================

Purpose
-------

Provide a central list of investors' [Ethereum] addresses, who are allowed to buy
or sell tokens.


Roles
-----

### Whitelist Owner  {#whitelist-role-owner}

Initially
~ the [Whitelist](#whitelist) contract deployer

Number
~ one at a time

Assignment
~ * by deploying the contract
  * by gaining ownership from previous owner

Permissions
~ * [transfer ownership](#ownable-func-transfer) to another account
  * assign/unassign [whitelist admins](#whitelist-role-admin)


### Whitelist Admins  {#whitelist-role-admin}

Authority which manages the whitelist.

Initially
~ none

Number
~ zero or more

Assignment
~ by getting [added or removed](#whitelist-func-admins) by the
  [whitelist owner](#whitelist-role-owner)

Permissions
~ add or remove [investors](#whitelist-role-investor) to/from the
  [whitelist](#whitelist)


### Whitelisted Investors  {#whitelist-role-investor}

Addresses of investors, who have completed and passed the KYC process.

Initially
~ none

Number
~ zero or more

Assignment
~ by getting [added or removed](#whitelist-func-investors) from the
  [whitelist](#whitelist) by a [whitelist admin](#whitelist-role-admin)

Permissions
~ none


Functionality
-------------

### Ownership

see [Ownable](#ownable)


### Admin Management  {#whitelist-func-admins}

#### Adding Admins

A single whitelist admin can be added.

Function
~ `addAdmin(address)`

Restrictions
~ only by [whitelist owner](#whitelist-role-owner)

Emitted events
~ `AdminAdded(address)`

#### Removing Admins

A single whitelist admin can be removed.

Function
~ `removeAdmin(address)`

Restrictions
~ only by [whitelist owner](#whitelist-role-owner)

Emitted events
~ `AdminRemoved(address)`


### Investor Management  {#whitelist-func-investors}

#### Whitelisting Investors

Several investors at once can be added to the whitelist.

Function
~ `addToWhitelist(address[])`

Restrictions
~ only by a [whitelist admin](#whitelist-role-admin)

Emitted events
~ `InvestorAdded(address, address)`

#### Unwhitelisting Investors

Several investors at once can be removed from the whitelist.

Function
~ `removeFromWhitelist(address[])`

Restrictions
~ only by a [whitelist admin](#whitelist-role-admin)

Emitted events
~ `InvestorRemoved(address, address)`



Crowdsale Contract  {#crowdsale}
==================

Purpose
-------

Enable token purchase by investors and check if the sale has to be considered
a success or a failure.
Refund investors upon sale failure.


Roles
-----

### Crowdsale Owner  {#crowdsale-role-owner}

Authority who administers the crowdsale.

Initially
~ the [Crowdsale](#crowdsale) contract deployer

Number
~ one at a time

Assignment
~ * by deploying the contract
  * by gaining ownership from previous owner

Permissions
~ * [transfer ownership](#ownable-func-transfer) to another account
  * distribute tokens to [investors](#crowdsale-role-investor) who paid in fiat
    currency (e.g. EUR) off-chain
  * [finalize](#crowdsale-func-finalization) the sale, but only
    #. once
    #. after the [public sale](#crowdsale-func-sale) has
       [closed](#crowdsale-life)


### Investors  {#crowdsale-role-investor}

Addresses who purchase tokens either via public or private sale.

Initially
~ all accounts that are whitelisted in the corresponding
  [whitelist](#whitelist)

Number
~ zero or more

Assignment
~ by being added or removed to/from the corresponding
  [whitelist](#whitelist)

Permissions
~ * [purchase tokens](#crowdsale-func-purchase) with Ether in public sale,
    but only
    #. while the sale is [open](#crowdsale-life)
    #. if there are enough tokens available for
       [public sale](#crowdsale-func-sale)
    #. if the amount of newly purchased tokens is at least a
       [predefined minimum](#crowdsale-func-purchase)
  * [claim refunds](#crowdsale-func-refunding), thus withdraw invested Ether,
    but only
    #. after [finalization](#crowdsale-func-finalization)
    #. if the [sale goal](#crowdsale-func-goal) was missed


### Rate Source  {#crowdsale-role-ratesource}

External contract which delivers the actual price of an Ether in Euro cents.

Initially
~ given to constructor

Number
~ one

Assignment
~ only once upon contract deployment

Permissions
~ none


### Token  {#crowdsale-role-token}

Reference to the [token](#token) instance which is sold by this crowdsale.

Initially
~ given to constructor

Number
~ one

Assignment
~ only once upon contract deployment

Permissions
~ none


### Company Wallet  {#crowdsale-role-companywallet}

Address which will receive all Ether that were paid by
[investors](#crowdsale-role-investor) to
[buy tokens](#crowdsale-func-purchase) during
[public sale](#crowdsale-func-sale) if the [goal](#crowdsale-func-goal) was
reached.
This is meant to be a multisig wallet.

Initially
~ given to constructor

Number
~ one

Assignment
~ only once upon contract deployment

Permissions
~ none


### Reserve Account  {#crowdsale-role-reserveaccount}

Address which will receive some additional amount of tokens
(depending on the total amount of sold tokens) upon
[finalization](#crowdsale-func-finalization) of a
[successful sale](#crowdsale-func-goal).
This is meant to be some vesting contract address.

Initially
~ given to constructor

Number
~ one

Assignment
~ only once upon contract deployment

Permissions
~ none


Functionality
-------------

### Ownership

see [Ownable](#ownable)


### Public vs. Private Sale  {#crowdsale-func-sale}

The crowdsale is divided into two distinct sales---a public and a private
sale---each being limited by its own *cap*. The cap is the maximum total
amount of tokens that can be bought in the respective sale.

Both caps are given to the constructor upon deployment
(parameters `tokenCapOfPublicSale` and `tokenCapOfPrivateSale`) in
token units (quantity of 10^-18^ tokens).

[Whitelisted investors](#whitelist-role-investor) can purchase tokens
in public or private sale off-chain by paying in fiat currency (e.g. Euro).
To make those investors receive their tokens, the crowdsale instance's
[owner](#crowdsale-role-owner) has to
[distribute](#crowdsale-func-distribution) them manually.

Additionally, as long as the public crowdsale is [open](#crowdsale-life),
investors can [purchase](#crowdsale-func-purchase) tokens directly by sending
Ether to the crowdsale instance.

#### Token Distribution  {#crowdsale-func-distribution}

[Whitelisted investors](#whitelist-role-investor) can purchase tokens
in public or private sale off-chain by paying in fiat currency (e.g. Euro).
To make these investors receive their tokens, the crowdsale instance's
[owner](#crowdsale-role-owner) has to distribute them manually via one of the
two token distribution methods.

**Note**
From the crowdsale smart contract's point of view the only distinction between
public or private sale is, which pool of available tokens the newly
minted tokens will be taken from.

Token distribution via public sale:

Function
~ `distributeTokensViaPublicSale(address[], uint[])`

Restrictions
~ * only by [owner](#crowdsale-role-owner)
  * only if crowdsale wasn't [finalized](#crowdsale-func-finalization) yet
  * only if sum of token amounts to distribute doesn't exceed the amount of
    remaining tokens for public sale

Emitted events
~ * `TokenDistribution(address, uint)`
  * `Minted(address, uint)`
  * `Transfer(0x0, address, uint)`


Token Distribution via private sale:

Function
~ `distributeTokensViaPrivateSale(address[], uint[])`

Restrictions
~ * only by [owner](#crowdsale-role-owner)
  * only if crowdsale wasn't [finalized](#crowdsale-func-finalization) yet
  * only if sum of token amounts to distribute doesn't exceed the amount of
    remaining tokens for private sale

Emitted events
~ * `TokenDistribution(address, uint)`
  * `Minted(address, uint)`
  * `Transfer(0x0, address, uint)`


### Purchase With Ether  {#crowdsale-func-purchase}

As long as the public crowdsale is [open](#crowdsale-life),
investors can [purchase](#crowdsale-func-purchase) tokens directly by sending
Ether to the crowdsale instance.

#### Purchase Minimum

When paying with Ether, the amount of tokens bought within a transaction has
to be at least some predefined lower limit which is given to constructor upon
deployment (parameter `tokenPurchaseMinimum`) in token units (quantity of
10^-18^ tokens).

Companies may decide to not define a lower threshold by setting
`tokenPurchaseMinimum` to zero.

#### Purchase Limit

During the start phase of the public sale, the total amount of tokens a single
investor can buy with Ether may be limited (parameter `tokenPurchaseLimit`).

When the start phase has ended (parameter `limitEndTime`) investors may buy
as much tokens as they want as long as the total cap for tokens purchasable
in public sale was not reached.

#### Token Price

The price of a token denominated in EUR-cents has to be given to the constructor
upon deployment (parameter `tokenPrice`).

The token price does not depend on the current Ether price. Therefore an
external contract---an instance of `RateSource`---is called upon every token
purchase with Ether to get the current Ether rate and adjust accordingly.

The amount of bought tokens is calculated as follows:

Let be
~ * *value* the sent Ether [in wei, i.e. 10^-18^ Ether],
  * *price* the token price [in €-cent per token],
  * *rate* the current Ether rate [in €-cent per Ether],
  * *amount* the purchased token amount [in token units, i.e. 10^-18^ tokens],

then
~ *amount* := *value* × *price* ÷ *rate*

[Whitelisted investors](#whitelist-role-investor) may purchase tokens via
the [public sale](#crowdsale-func-sale) by sending Ether to the crowdsale instance.

Functions
~ * `payable buyTokens()`
  * `payable` fallback function

Restrictions
~ * only by [whitelisted investors](#whitelist-role-investor)
  * only while the public sale is [open](#crowdsale-life) that is
    from opening time till closing time
  * only if amount of bought tokens in a single transaction is at least
    a predefined minimum purchase amount
  * only if amount of bought tokens doesn't exceed the amount of remaining
    tokens for public sale

Emitted events
~ * `TokenPurchase(address, uint, uint)`
  * `Minted(address, uint)`
  * `Transfer(0x0, address, uint)`


### Softcap / Sale Goal  {#crowdsale-func-goal}

Upon crowdsale deployment a predefined softcap (parameter `tokenGoal`) can be
given to the constructor, which determines a goal, i.e. the minimum amount of
sold token in both---public and private---sales, that has to be reached for
the crowdsale to become a success.

If the goal was reached, the sale is considered successful, otherwise it is
considered a failure.

During sale period, as long as the goal wasn't reached, invested Ether
are accumulated in the crowdsale contract. After the goal was reached,
all invested Ether are transferred to the
[company wallet](#crowdsale-role-companywallet) address

Companies may decide to not define a goal by setting `tokenGoal` to zero.

### Change of the ClosingTime

The Closing time of the crowdsale can be changed by the crowdsale [owner](#crowdsale-role-owner).  This allows the crowdsale [owner](#crowdsale-role-owner) to decrease the offering period in case the crowdsale is already fully sold. It also allows to extend the offering period to a maximum of 80 days. In case the offering preiod is already longer than 80 days the offering period can not be extended.

Function
~ `changeClosingTime()`

Restrictions
~ * only by crowdsale [owner](#crowdsale-role-owner)
  * only before the public sale has closed
  * only if closingTime is in the future
  * only if offering period is longer than 0 afterwards
  * only if offering period is not longer than 80 days afterwards.

Emitted events
~ * `ClosingTimeChange(uint, uint)`

### Finalization  {#crowdsale-func-finalization}

After the crowdsale has ended, it has to be finalized manually by the
crowdsale [owner](#crowdsale-role-owner).
Depending on whether the [sale goal](#crowdsale-func-goal) was reached, this
will either

* if the goal was reached:

  #. mint additional tokens, i.e. a predefined percentage of total amount of
     sold tokens, for the benefit of the
     [reserve account](#crowdsale-role-reserveaccount)
  #. [finish minting](#token-func-minting) of the token, thus fixing its
     total supply

* if the goal was missed:

  #. destroy the [token](#token) instance
  #. enable the [refunding](#crowdsale-func-refunding) of investors who
     [paid by sending Ether directly](#crowdsale-func-purchase) to the
     crowdsale instance.

Function
~ `finalize()`

Restrictions
~ * only by crowdsale [owner](#crowdsale-role-owner)
  * only after the public sale has closed
  * only once

Emitted events
~ Depending on the success of sale:

  #. if goal was reached

     * `Minted(address, uint)`
     * `Transfer(0x0, address, uint)`
     * `Finalization()`

  #. if goal was missed

     * `Finalization()`
     * `TokenDestroyed()`



### Refunding  {#crowdsale-func-refunding}

If the [sale goal](#crowdsale-func-goal) was not reached, the crowdsale is
considered a failure and [investors](#crowdsale-role-investor) who
[purchased](#crowdsale-func-purchase) tokens by sending Ether directly
to the crowdsale instance can claim a refund.

#### Distribute Refunds

Anybody may distribute the refunds to investors, so that the latter don't
need to withdraw them by themselves.

Function
~ `distributeRefunds(address[])`

Restrictions
~ * only if the crowdsale was [finalized](#crowdsale-func-finalization)
  * only if the [sale goal](#crowdsale-func-goal) was missed

Emitted events
~ `InvestorRefund(address, uint)`

#### Claiming Refunds

Investors may get their invested Ether back by claiming them by themselves.

Function
~ `claimRefund()`

Restrictions
~ * only if the crowdsale was [finalized](#crowdsale-func-finalization)
  * only if the [sale goal](#crowdsale-func-goal) was missed

Emitted events
~ `InvestorRefund(address, uint)`


Lifecycle  {#crowdsale-life}
---------

### Before Start of Public Sale Phase

Start time
~ at deployment

End time
~ at `openingTime`

### Public Sale Phase

The public sale is open for [investors](#whitelist-role-investor) who want
to [buy token with Ether](#crowdsale-func-purchase) from opening time till
closing time given as Ethereum block timestamps (UNIX epoch) to constructor
upon deployment (parameters `openingTime`, `closingTime`, `limitEndTime`).

During the start phase of a public sale the total amount of tokens a buyer
may purchase can be limited:

Start time
~ at `openingTime`

End time
~ at `limitEndTime`

During the remaining time of a public sale the amount of tokens a buyer
can purchase is only constrained by the total cap.

Start time
~ at `limitEndTime`

End time
~ at `closingTime`

A `limitEndTime` that lies either before `openingTime` or after `closingTime`
is perfectly valid and either never or always limits the individual total amount
of tokens bought with Ether.


### Between End of Public Sale Phase and Finalization

After the public sale has closed, the crowdsale [owner](#crowdsale-role-owner)
is expected to manually [finalize](#crowdsale-func-finalization) the
crowdsale.
Before doing so, he/she must [distribute](#crowdsale-func-distribution)
tokens to [investors](#whitelist-role-investor) who have purchased them
off-chain.

Start time
~ at `closingTime`

End time
~ upon call of `finalize()`


### After Finalization

After [finalization](#crowdsale-func-finalization) no tokens can be minted
anymore, i.e. the [total token supply is fixed](#token-func-fixing).
Depending on whether the [sale was successful](#crowdsale-func-goal) or not,
[token holder](#token-role-holder) either may trade their tokens and withdraw
their profit shares, or [claim refunds](#crowdsale-func-refunding).

Start time
~ upon call of `finalize()`

End time
~ never



Token Contract  {#token}
==============

Purpose
-------

The `Token` contract is an [ERC20] compliant profit sharing token.

[ERC20]: https://theethereum.wiki/w/index.php/ERC20_Token_Standard


Roles  {#token-role}
-----

### Token Owner  {#token-role-owner}

Role administrating authority.

Initially
~ the [Token](#token) contract deployer

Number
~ one at a time

Assignment
~ * by deploying the contract
  * by gaining ownership from previous owner

Permissions
~ * [transfer ownership](#ownable-func-transfer) to another account
  * assign [minter](#token-role-minter), but only once
  * assign [profit depositor](#token-role-depositor)
  * assign [profit distributor](#token-role-distributor)
  * assign [token recoverer](#token-role-recoverer)


### Token Minter  {#token-role-minter}

Authority who is allowed to [mint](#token-func-minting) some amount of tokens
for the benefit of whitelisted investors and to finish minting, thus fixing
the token's total supply.

Initially
~ none

Number
~ zero or one

Assignment
~ only once by the [token owner](#token-role-owner)
~ *Note*, this is expected to be a [Crowdsale](#crowdsale) instance

Permissions
~ * [mint tokens](#token-func-minting) for the benefit of some investor,
    but only
    #. while minting was not finished
    #. the investor is whitelisted
  * finish minting, but only once
  * destroy the token contract


### Whitelist {#token-role-whitelist}

A [Whitelist](#whitelist) contract instance which restricts the
addresses who are able to send or receive tokens.

Initially
~ given to constructor

Number
~ one at a time

Assignment
~ by the [token owner](#token-role-owner)

Permissions
~ none


### Profit Depositor  {#token-role-depositor}

Authority who is able to [deposit company profits](#token-func-profitdeposit)
(in Ether) into the token contract instance.

Initially
~ given to constructor

Number
~ one at a time

Assignment
~ by the [token owner](#token-role-owner)

Permissions
~ deposit profits, i.e. store some Ether amount into the Token instance


### Profit Distributor  {#token-role-distributor}

Authority who is able to [distribute profit shares](#token-func-profitshare)
(in Ether) to token holders on their behalf, thus the latter don't need to
withdraw their profit shares by themselves.

Initially
~ none

Number
~ one at a time

Assignment
~ by the [Token owner](#token-role-owner)

Permissions
~ distribute profit shares to [token holders](#token-role-investor),
  i.e. transfer some fraction of the Ether amount deposited in the token
  to investors according to their amount of tokens they hold


### Token Recoverer  {#token-role-recoverer}

Authority who may [assign a new address](#token-func-tokenrecovery) to a
token holder's account.

Initially
~ given to constructor

Number
~ one at a time

Assignment
~ by the [Token owner](#token-role-owner)

Permissions
~ transfer investor account data from one address to another, but only
  if the new (destination) address was not already assigned to an investor's
  account


### Token Holders  {#token-role-holder}

Addresses who hold some amount of tokens, thus have an account within
the token contract instance.

Initially
~ none

Number
~ zero or more

Assignment
~ by first being [whitelisted](#whitelist-role-investor) and then by
  purchasing tokens in the public or private [crowdsale](#crowdsale) or
  receiving tokens transferred from another token holder

Permissions
~ * withdraw some fraction from profit deposited in the token, but only
    #. up to the amount of share he/she is owed
    #. if the [minting](#token-func-minting) was finished, i.e. the total
       supply of the [token doesn't change](#token-func-fixing) anymore
  * transfer some tokens to another
    [whitelisted investor](#whitelist-role-investor)
  * approve some third party trustee to transfer some amount of tokens from
    the token holder's account to another
    [whitelisted investor](#whitelist-role-investor)

**Note**
A token holder may not always be also a
[whitelisted investor](#whitelist-role-investor), because he/she may get
removed from the [whitelist](#whitelist) after the receipt of tokens or
because the token instance's [whitelist](#whitelist) was exchanged.


### Third Party Trustees  {#token-role-trustee}

Addresses who are allowed by a token holder to transfer some limited amount
of tokens on the token holder's behalf.

Initially
~ none

Number
~ zero or more

Assignment
~ by getting approved by a [token holder](#token-role-holder)

Permissions
~ transfer up to some allowed amount of tokens from the
  [token holder's](#token-role-holder) account to some other
  [whitelisted investor](#whitelist-role-investor)


Functionality
-------------

### Ownership

see [Ownable](#ownable)


### Role Management  {#token-func-roles}

The token instance's [owner](#token-role-owner) can set the addresses of
the following authorities (roles):

#.  [Minter](#token-role-minter), that is the related
    [crowdsale](#crowdsale) contract instance

    Function
    ~ `setMinter(address)`

    Restrictions
    ~ * only by [owner](#token-role-owner)
      * only once

    Emitted events
    ~ none

#.  [Profit depositor](#token-role-depositor)

    Function
    ~ `setProfitDepositor(address)`

    Restrictions
    ~ only by [owner](#token-role-owner)

    Emitted events
    ~ `ProfitDistributorChange(address)`

#.  [Profit distributor](#token-role-distributor)

    Function
    ~ `setProfitDistributor(address)`

    Restrictions
    ~ only by [owner](#token-role-owner)

    Emitted events
    ~ `ProfitDepositorChange(address)`

#.  [Token recoverer](#token-role-recoverer)

    Function
    ~ `setTokenRecoverer(address)`

    Restrictions
    ~ only by [owner](#token-role-owner)

    Emitted events
    ~ `TokenRecovererChange(address, address)`


### Whitelist Checks  {#token-func-whitelist}

Prior to being able to send or receive any amount of tokens, both---the token
sender and the token recipient---have to be
[whitelisted investors](#whitelist-role-investor) in the
[Whitelist](#whitelist) instance that is assigned to the
[token contract](#token).

This holds true for all function related to
[token minting](#token-func-minting) and
[token transfers](#token-func-transfer).


### Minting and Fixing Total Supply

#### Minting Tokens  {#token-func-minting}

The token's total supply is initially not fixed. That means, the
[minter](#token-role-minter) can create new tokens out of thin air and book
them to any [whitelisted investor](#whitelist-role-investor).

Function
~ `mint(address, uint)`

Restrictions
~ * only by [minter](#token-role-minter)
  * if total supply wasn't fixed
  * token recipient must be [whitelisted](#whitelist-role-investor)

Emitted events
~ * `Minted(address, uint)`
  * `Transfer(0x0, address, uint)`

#### Fixing Total Supply  {#token-func-fixing}

As long as the total token supply is not fixed, token holders won't be
able to withdraw their Ether share of profits deposited in the token
contract instance.
The minter will eventually finish the minting, thus fixing the total supply
of the token. This will happen upon [crowdsale](#crowdsale) finalization.

Function
~ `finishMinting()`

Restrictions
~ * only by [minter](#token-role-minter)
  * if total supply wasn't fixed yet

Emitted events
~ `MintFinished()`

**Note**
Fixing the token's total supply is *irreversible*.


### Profit Sharing

#### Profit Deposit  {#token-func-profitdeposit}

Profits are distributed to [token holder](#token-role-holder) by depositing
Ether in the token contract, that is, the token's
[profit depositor](#token-role-depositor) authority sends Ether to the
token contract instance.

Functions
~ * `payable depositProfits()`
  * `payable` fallback function

Restrictions
~ * only by [profit depositor](#token-role-depositor)
  * only after the token's total supply was fixed
  * only if the token's total supply is greater than zero

Emitted events
~ `ProfitDeposit(address, uint)`

#### Profit Share  {#token-func-profitshare}

Profits, i.e. the Ether currently stored in the token contract, are
distributed to [token holders](#token-role-holder) according to their
share of the token's total supply.

The token contract ensures that regardless of whether a token holder
withdraws his/her profit share immediately after new profits were
deposited or waits for several profit deposits to have happened, even if
tokens were transferred in the meantime, the profit share will he/she
can claim always reflects his/her token share.

##### Profit Share Calculation

The profit share of an investor is related to his/her token share:

Let be
~ * *totalSupply* the total supply of tokens,
  * *balance~Inv~* the amount of tokens held by the investor,
  * *ΔtotalProfits* the additional profits [in Ether]
    which where deposited into the token instance
    since the investor's last profit share withdrawal,
  * *ΔprofitShare~Inv~* the owing profit share [in Ether],
    that is additional profit share
    since the investor's last profit share withdrawal,

then
~ *balance~Inv~* ÷ *totalSupply* = *ΔprofitShare~Inv~* ÷ *ΔtotalProfits*

**Note**
A prerequisite to correct profit share calculation is a non-changing
token's total supply. This means, profit shares won't get calculated and
aren't withdrawable as long as the total supply wasn't fixed, that is,
while the [crowdsale](#crowdsale) is still ongoing.

##### Determining Owing Profit Shares

The currently owed profit share of an investor can be determined:

Function
~ `profitShareOwing(address)`

Restrictions
~ none, but until after the token's total supply was fixed (the
  [crowdsale](#crowdsale) was finalized) this function won't calculate
  the correct value but return `0`

##### Updating Individual Profit Shares

Whenever a profit share withdrawal or a token transfer takes place,
the profit shares of the involved token holding parties have to be
updated first. Profit share updating means, the owed profit share of a
token holder up to this moment are calculated and saved.

Function
~ `updateProfitShare(address)`

Restrictions
~ only after the token's total supply was fixed

Emitted events
~ `ProfitShareUpdate(address, uint)`

##### Profit Share Withdrawal

There are three possible ways for [token holders](#token-role-holder)
to get their owed profit share withdrawn from the token.

#. Withdraw by themselves and receive the profit share (Ether) on their
   Ethereum address

   Function
   ~ `withdrawProfitShare()`

   Restrictions
   ~ only after the token's total supply was fixed

   Emitted events
   ~ `ProfitShareWithdrawal(address, address, uint)`

#. Withdraw by themselves but send the profit share (Ether) to another
   Ethereum address

   Function
   ~ `withdrawProfitShareTo(address)`

   Restrictions
   ~ only after the token's total supply was fixed

   Emitted events
   ~ `ProfitShareWithdrawal(address, address, uint)`

#. Bulk Withdrawal by the [profit distributor](#token-role-distributor)
   authority which sends the Ether to the [token holders'](#token-role-holder)
   Ethereum addresses

   Function
   ~ `withdrawProfitShares(address[])`

   Restrictions
   ~ * only by [profit distributor](#token-role-distributor)
     * only after the token's total supply was fixed

   Emitted events
   ~ `ProfitShareWithdrawal(address, address, uint)`


### Token Transfers  {#token-func-transfer}

Token transfers are possible via the [ERC20] functions:

#.  A [token holder](#token-role-holder) can send tokens to another
    [whitelisted investor](#whitelist-role-investor)

    Function
    ~ `transfer(address, uint)`

    Restrictions
    ~ * only if the sender is a
        [whitelisted investor](#whitelist-role-investor)
      * only if the recipients is a
        [whitelisted investor](#whitelist-role-investor)
      * only if the total supply is fixed

    Emitted events
    ~ `Transfer(address, address, uint)`

#.  A [token holder](#token-role-holder) can approve a
    [third party trustee](#token-role-trustee) to transfer up to some amount
    of tokens from the token holders account to any
    [whitelisted investor](#whitelist-role-investor)

    Function
    ~ `approve(address, uint)`

    Restrictions
    ~ * only if the sender is a
        [whitelisted investor](#whitelist-role-investor)
      * only if the total supply is fixed

    Emitted events
    ~ `Approval(address, address, uint)`

#.  A [third party trustee](#token-role-trustee) can transfer up to some
    allowed limit of an [token holder's](#token-role-holder) account to
    another [whitelisted investor](#whitelist-role-investor)

    Function
    ~ `transferFrom(address, address, uint)`

    Restrictions
    ~ * only by a [trustee](#token-role-trustee) approved by the
        [token holder](#token-role-holder)
      * only if the token amount is below the allowed amount
      * only if the [token holder](#token-role-holder) is a
        [whitelisted investor](#whitelist-role-investor)
      * only if the recipient is a
        [whitelisted investor](#whitelist-role-investor)

    Emitted events
    ~ `Transfer(address, address, uint)`


### Token Recovery  {#token-func-tokenrecovery}

In case a [token holders](#token-role-holder) wants to change his/her Ethereum
address, e.g. if he/she lost his/her private key or his account was
compromised, the [token recoverer](#token-role-recoverer) authority can attach
the account related data to the token holder's new address.

Function
~ `recoverToken(address, address)`

Restrictions
~ * only by [token recoverer](#token-role-recoverer)
  * only if the new address isn't already assigned to some account data within
    this token instance

Emitted events
~ * `TokenRecovery(address, address)`
  * `Transfer(address, address, uint)`


### Destruction  {#token-func-destruction}

If the token sale wasn't successful, that is the total amount of tokens sold
in both (public and private) sales of the [crowdsale](#crowdsale) hasn't
reached the predefined goal, the token contract instance gets destructed,
i.e. removed from the Ethereum ledger.

Any profits deposited in the token instance will be transferred to the
[token owner](#token-role-owner) upon destruction.

Function
~ `destruct()`

Restrictions
~ only by [minter](#token-role-minter), i.e. the related
  [crowdsale](#crowdsale) instance

Emitted events
~ none


Lifecycle
---------

### Minting Phase

As long as the token's [crowdsale](#crowdsale) was not finalized
tokens can be [minted](#token-func-minting), i.e. created out of thin air by
the [minter](#token-role-minter) authority, which is supposed to be the
[crowdsale instance](#crowdsale) itself.

Start time
~ at deployment

End time
~ * upon call of `finishMinting()`
  * upon token [destruction](#token-func-destruction)


### Trading Phase

After the [minting](#token-func-minting) was finished, the token's
total supply is [fixed](#token-func-fixing), thus
[Token holder](#token-role-holder) can withdraw their
[profit share](#token-func-profitshare) and are allowed to trade
([transfer](#token-func-transfer)) their tokens with others.

Start time
~ upon call of `finishMinting()`

End time
~ never



Project Manager  {#manager}
===============

Purpose
-------

Keep a central list of and create new *project*, where a project is a
data structure containing:

#. the name of the project,
#. the associated [whitelist](#whitelist) contract instance,
#. the associated [token](#token) contract instance,
#. the associated [crowdsale](#crowdsale) contract instance.

Additionally, the project manager acts as the rate source for the
managed crowdsale contracts.


Roles
-----

### Project Manager Owner  {#manager-role-owner}

Initially
~ the [Project Manager](#manager) contract deployer

Number
~ one at a time

Assignment
~ * by deploying the contract
  * by gaining ownership from previous owner

Permissions
~ * [transfer ownership](#ownable-func-transfer) to another account
  * set [current whitelist](#manager-role-whitelist)
  * set [token factory](#manager-role-tokenfactory)
  * set [crowdsale factory](#manager-role-crowdsalefactory)
  * set [rate admin](#manager-role-rateadmin)


### Whitelist  {#manager-role-whitelist}

Current [whitelist](#whitelist) which will be initially used in newly
created projects.

Initially
~ none

Number
~ zero or one

Assignment
~ only by [project manager owner](#manager-role-owner)

Permissions
~ update current Ether rate


### Token Factory  {#manager-role-tokenfactory}

A helper contract to deploy new [token contracts](#token).

Initially
~ none

Number
~ zero or one

Assignment
~ only by [project manager owner](#manager-role-owner)

Permissions
~ update current Ether rate


### Crowdsale Factory  {#manager-role-crowdsalefactory}

A helper contract to deploy new [crowdsale contracts](#crowdsale).

Initially
~ none

Number
~ zero or one

Assignment
~ only by [project manager owner](#manager-role-owner)

Permissions
~ update current Ether rate


### Rate Admin  {#manager-role-rateadmin}

Authority who adjusts the ether rate to the current Ether price
in Euro cents.

Initially
~ none

Number
~ zero or one

Assignment
~ only by [project manager owner](#manager-role-owner)

Permissions
~ update current Ether rate


Functionality
-------------

### Role Management  {#manager-func-roles}

The project manager instance's [owner](#manager-role-owner) can set the
addresses of the following roles:

#.  [Current whitelist](#manager-role-whitelist)

    Function
    ~ `setWhitelist(address)`

    Restrictions
    ~ only by [owner](#manager-role-owner)

    Emitted events
    ~ none

#.  [Token factory](#manager-role-tokenfactory)

    Function
    ~ `setTokenFactory(address)`

    Restrictions
    ~ only by [owner](#manager-role-owner)

    Emitted events
    ~ none

#.  [Crowdsale factory](#manager-role-crowdsalefactory)

    Function
    ~ `setCrowdsaleFactory(address)`

    Restrictions
    ~ only by [owner](#manager-role-owner)

    Emitted events
    ~ none

#.  [Rate admin](#manager-role-rateadmin)

    Function
    ~ `setRateAdmin(address)`

    Restrictions
    ~ only by [owner](#manager-role-owner)

    Emitted events
    ~ `RateAdminChange(address, address)`



### Project Creation  {#manager-func-projectcreation}

Creating a project involves several steps:

#. deploy a [token](#token) instance which is assigned to the
   [current whitelist](#manager-role-whitelist),
#. deploy a [crowdsale](#crowdsale) instance which is assigned
   to the token and the project manager as its
   [rate source](#manager-func-ratesource)
#. set the crowdsale to be the [minter](#token-role-minter)
   of its token
#. save the project (the three contracts) along with the project
   name in the `projects` list

The project manager allows to easily set up a new project.
It utilizes two helper factory contracts.

Function
~ createNewProject(...)

Restrictions
~ only by [project manager owner](#manager-role-owner)

Emitted events
~ none


### Rate Source  {#manager-func-ratesource}

As the [token price](#crowdsale-func-purchase) denominated in EUR-cents
should be constant, the Ether rate has to be adjusted regularly to the
current Ether price (in EUR-cents).

[Tokens](#token) which were deployed by the project manager will
have this contract set as their rate source.

#### Reading Current Rate

Function
~ `etherRate()`

Restrictions
~ none

#### Updating Current Rate

Function
~ `setEtherRate(uint)`

Restrictions
~ only by [rate admin](#manager-role-rateadmin)

Emitted events
~ `RateChange(uint, uint)`
